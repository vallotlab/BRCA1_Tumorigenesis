---
title: "Step5_TF_Enrichment_2_SCENIC"
author: "Melissa"
date: "18/10/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
mainDir <- here::here() # the MainDir should be the root of Tumor_BRCA_P53:
source(knitr::purl(file.path(mainDir,"Scripts","global_var_current.Rmd"), quiet=TRUE))
source(knitr::purl(file.path(mainDir,"Scripts","scRNAseq_Functions.Rmd"), quiet=TRUE))
source(knitr::purl(file.path(mainDir,"Scripts","global_variables.Rmd"), quiet=TRUE))
```


LAUNCH SCENIC:

```{r}
#--Prepare and load the data ----##

setwd(scenicDir)
dir.create(paste0(scenicDir,"/cisTarget_databases")) # Build the database folder

##---------Load datasets and colors----------##
epith_cols=qs::qread(paste0(RDatadir,"/Epith_Cols_Subtype.qs"))

seu= qs::qread(paste0(RDatadir,"/Epithelial_FinalAnnotation.qs"))

#---- Download RcisTarget databases -----##
dbFiles <- c("https://resources.aertslab.org/cistarget/databases/homo_sapiens/hg19/refseq_r45/mc9nr/gene_based/hg19-500bp-upstream-7species.mc9nr.feather",
"https://resources.aertslab.org/cistarget/databases/homo_sapiens/hg19/refseq_r45/mc9nr/gene_based/hg19-tss-centered-10kb-7species.mc9nr.feather")

setwd(paste0(scenicDir,"/cisTarget_databases"))

for(featherURL in dbFiles)
{
  download.file(featherURL, destfile=basename(featherURL)) # saved in current dir
}

#---- Check if databases were correctly ordered ----##
SCENIC::dbLoadingAttempt(dbPath)
rnk <- RcisTarget::importRankings(dbPath, indexCol="features", columns=c("Sox10","Dlx1"))


library(SCENIC)
org <- "mgi"
dbDir <- paste0(scenicDir,"/cisTarget_databases")

myDatasetTitle <- "SCENIC test" # choose a name for your analysis
data(defaultDbNames)
dbs <- defaultDbNames[[org]]
scenicOptions <- initializeScenic(org=org, dbDir=dbDir, dbs=dbs, datasetTitle=myDatasetTitle, nCores=7)  
```


```{r}
setwd(scenicDir)
cellInfo <- data.frame(seu@meta.data)
colnames(cellInfo)[which(colnames(cellInfo)=="orig.ident")] <- "sample"
colnames(cellInfo)[which(colnames(cellInfo)=="nFeature_RNA")] <- "nGene"
colnames(cellInfo)[which(colnames(cellInfo)=="nCount_RNA")] <- "nUMI"
colnames(cellInfo)[which(colnames(cellInfo)=="seurat_clusters")] <- "cluster"
colnames(cellInfo)[which(colnames(cellInfo)=="subtype")] <- "celltype"
cellInfo <- cellInfo[,c("sample","nGene","nUMI","cluster","celltype")]
#----------------------------------###
scenicOptions@inputDatasetInfo$cellInfo <- cellInfo
scenicOptions@inputDatasetInfo$colVars <- as.list(epith_cols)

saveRDS(scenicOptions, file=paste0(scenicDir, "/int/scenicOptions.Rds"))
```


```{r}
setwd(scenicDir)
getwd()
scenicOptions@settings$modules$weightThreshold= 0.05

sseu= subset(seu, idents = c("LP", "Avd", "P16+ Pre-lesional","Mki67+ ST", "Cytl1+ ST","Fgf8+ ST","Spp1+ ST" ))

exprMat <- as.matrix(sseu@assays$RNA@counts) #Prepare the expression matrix. In order to save computing resources, only some cells are randomly selected to calculate the co-expression network

genesKept <- geneFiltering(exprMat, 
                           scenicOptions=scenicOptions,minCountsPerGene=5*.01*ncol(exprMat),minSamples=ncol(exprMat)*.05) #Gene filtering/selection, remove genes that are most likely to be noise

exprMat_filtered <- exprMat[genesKept, ]

dim(exprMat_filtered)

runCorrelation(exprMat_filtered, scenicOptions) ##Calculate the correlation matrix, 1.2_corrMat.Rds: the correlation matrix between genes
```

```{r}
##GENIE3, the input of GENIE3 is usually an expression matrix and a list of candidate regulators.
exprMat_filtered <- log2(exprMat_filtered+1) #complete matrix
runGenie3(exprMat_filtered, scenicOptions, nParts = 5) #nParts parameter, is to divide the expression matrix into n parts and calculate separately
```

Run SCENIC 
```{r}
setwd(scenicDir)
library(doParallel)
library(doRNG)
getwd()
exprMat_log <- log2(exprMat+1) #log standard words original matrix
#scenicOptions <- readRDS("int/scenicOptions.Rds")
scenicOptions@settings$verbose <- TRUE
scenicOptions@settings$nCores <- 1

scenicOptions@settings$seed <- 123
scenicOptions@settings$modules$weightThreshold= 0.01

scenicOptions <- runSCENIC_1_coexNetwork2modules(scenicOptions) #1. Get coexpression module

scenicOptions <- runSCENIC_2_createRegulons(scenicOptions,coexMethod=c("top10perTarget")) 
scenicOptions <- runSCENIC_3_scoreCells(scenicOptions, exprMat_log) #3. Scoring the GRN (regulator) in the cell

saveRDS(scenicOptions, file=paste0(scenicDir,"/int/scenicOptions.Rds"))

runSCENIC_4_aucell_binarize(scenicOptions, exprMat=exprMat_log)
```


Work on SCENIC OUTPUT
```{r}
##Import the original regulonAUC matrix, which is the AUC matrix generated after running runSCENIC_3_scoreCells, you can view the AUC activity score of each GRN in each cell

AUCmatrix <- readRDS(paste0(scenicDir,"/int/3.4_regulonAUC.Rds"))
AUCmatrix <- data.frame(t(AUCmatrix@assays@data@listData$AUC), check.names=F)
RegulonName_AUC <- colnames(AUCmatrix)
RegulonName_AUC <- gsub(' \\(','_',RegulonName_AUC) #replace "(" with "_"
RegulonName_AUC <- gsub('\\)','',RegulonName_AUC) # Remove ")" and finally replace KLF3_extended (79g) with KLF3_extended_79g
colnames(AUCmatrix) <- RegulonName_AUC
library(Seurat)
sseu <- AddMetaData(sseu, AUCmatrix) # Add the AUC matrix to the metadata information of pbmc
AUCmatrix$celltype= sseu$subtype
pbmcauc@assays$integrated <- NULL
qs::qsave(sseu, paste0(scenicDir, "/Sub_Seurat_InvivoMouse_WithAUC.qs"))

sseu=qs::qread(paste0(scenicDir, "/Sub_Seurat_InvivoMouse_WithAUC.qs"))
```


Plots of TFs:
Visualize the top genes:
```{r}
metadata= data.frame("subtype"=sseu2@meta.data$subtype)
rownames(metadata)= colnames(sseu2)
#metadata= metadata[, -1] %>% as.data.frame()
colours <- list("subtype"=epith_cols)
####---------------------##
colAnn <- HeatmapAnnotation(df = metadata,
  which = 'col',
  col = colours,
  annotation_width = unit(c(1, 4), 'cm'),
  gap = unit(0.5, 'mm'))
#identical(rownames(metadata), rownames(AUCmatrix))
```

```{r}
dt= sseu2@meta.data
dt= dt %>% dplyr::select(grep("g$", colnames(dt), value = TRUE))
dt= dt %>% select(! grep("extended",colnames(dt), value = TRUE))
```


```{r}
split <- factor( metadata$subtype,levels = c("LP","Avd","P16+ Pre-lesional", "Mki67+ ST","Spp1+ ST","Cytl1+ ST","Fgf8+ ST" ))

hmap <- Heatmap(
  t(dt),
  name = "TF SCENIC module scores",
 # col = bluered(75), 
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows =TRUE,
  cluster_columns = FALSE,
  show_column_dend = FALSE,
  show_row_dend = TRUE,
  row_dend_reorder = FALSE,
  column_dend_reorder = FALSE,
  clustering_method_rows = "ward.D2",
  clustering_method_columns = NULL,
  #width = unit(100, "mm"),
  top_annotation=colAnn,row_names_gp = gpar(fontsize = 8, fontfamily = "sans"),column_split=split,column_names_gp = gpar(fontsize = 4, fontfamily = "sans"))

pdf(paste0(scenicDir, "Heatmap_SCENIC_AUCMatrix_ScoreModules_SeuSubset.pdf"), height = 10, width = 12)
draw(hmap, heatmap_legend_side="right", annotation_legend_side="right")
dev.off()
#---------
png(paste0(scenicDir, "Heatmap_SCENIC_AUCMatrix_ScoreModules_SeuSubset.png"), height = 2000, width = 2800, res=300)
print(hmap)
dev.off()
```

```{r}
x= apply(AUCmatrix, 2, var) %>% as.data.frame()
colnames(x)= "variance"
rownames(x)[which(x$variance > 0.01)]
```



Merge with pseudotime:
```{r}
seup= qs::qread(paste0(RDatadir,"/SeuObj_Subset_WithPseudotime.qs"))
sseu$pseudotime= seup$pseudotime

qs::qsave(sseu, paste0(scenicDir, "/Sub_Seurat_InvivoMouse_WithAUC_Binary.qs"))
sseu=qs::qread(paste0(scenicDir, "/Sub_Seurat_InvivoMouse_WithAUC_Binary.qs"))
#---------------------

AUCmatrix$pseudotime= sseu$pseudotime

dt= AUCmatrix[-which(is.na(AUCmatrix$pseudotime)==TRUE),]
plot(hclust(as.dist(1-cor(dt))), hang = -0.1)
```



For TFs:

```{r}
sseu=qs::qread(paste0(outputDir, "/Sub_Seurat_InvivoMouse_WithAUC_Binary.qs"))
coord= sseu@reductions$umap@cell.embeddings %>% as.data.frame()
coord= coord %>% filter(UMAP_2 > (-5)) %>% filter(UMAP_2 < 5.5)
sseu2= subset(sseu, cells= rownames(coord))
sseu2= subset(sseu2, idents = c("LP", "Avd", "P16+ Pre-lesional","Mki67+ ST","Cytl1+ ST","Fgf8+ ST"))
coord= sseu2@reductions$umap@cell.embeddings %>% as.data.frame()
coord= coord  %>% filter(UMAP_2 < 3.5)
sseu2= subset(sseu2, cells= rownames(coord))
```

Twist1_27g
```{r}

png(paste0(outputDir, "UMAP_Twist1_GeneExpression2.png"), height=2000, width = 2000,res=300)
 p <- FeaturePlot(sseu2, features = "Twist1", pt.size=2.75) + 
      geom_point(data= as.data.frame(sseu2[["umap"]]@cell.embeddings) , aes(x =UMAP_1, y = UMAP_2, fill= sseu2@assays$RNA@data["Twist1",],stroke=0.5), shape = 21,stroke=0.5, colour= "black", size=2.75 )   + scale_fill_viridis(option="B",limits = c(0.01, max(sseu2@assays$RNA@data["Twist1",])),  na.value= "grey",direction=-1) + NoLegend() + NoAxes() + ggtitle("")
 
#p[[1]]$layers[[1]]$aes_params$alpha = 0.4
print(p)
dev.off()

png(paste0(outputDir, "UMAP_Twist1_Module_SCENIC2.png"), height=2000, width = 2000,res=300)
p <- FeaturePlot(sseu2, features = "Twist1_27g", pt.size=2.75) + 
      geom_point(data= as.data.frame(sseu2[["umap"]]@cell.embeddings) , aes(x =UMAP_1, y = UMAP_2, fill= sseu2$Twist1_27g,stroke=0.5), shape = 21,stroke=0.5, colour= "black", size=2.75 )   + scale_fill_viridis(option="B",limits = c(0.01, max(sseu2$Twist1_27g)),  na.value= "grey",direction=-1) + NoLegend() + NoAxes() + ggtitle("")
#p[[1]]$layers[[1]]$aes_params$alpha = 0.4
print(p)
dev.off()
```


```{r}
df <- sseu2@meta.data %>% dplyr::select(c(grep("g$", colnames(sseu2@meta.data), value = TRUE), "pseudotime"))
df= df %>% select(! grep("extended",colnames(df), value = TRUE))

df=df %>% filter(! is.na(pseudotime))
corrplot::corrplot(cor(df))
mcor= cor(df)
mcor=mcor[nrow(mcor),] %>% as.data.frame()
colnames(mcor)="corr"
mcor$TF= rownames(mcor)
mcor= mcor %>% filter(!TF=="pseudotime")
mcor$group= ifelse(mcor$corr < 0, "Neg", "Pos")
mcor=mcor[order(mcor$corr, decreasing = FALSE),]

pdf(paste0(outputDir, "/Barplot_TFs_CorrelationPseudotime.pdf"))
p <- mcor %>% ggplot(aes(x= reorder(TF, -corr), y=  corr)) + geom_bar(stat="identity", color="black", fill="white") + themplot   + theme(axis.text.x = element_text(angle = 90, hjust = 1)) 
print(p)
dev.off()
```

